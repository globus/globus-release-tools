#! /usr/bin/python

# Copyright 2014-2015 University of Chicago
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import print_function

import argparse
import grp
import os
import socket
import sys

sys.path.append(os.path.join(
        os.path.dirname(sys.argv[0]),
        "..",
        "share",
        "python"))

import repo
import repo.deb
import repo.packages
import repo.installers
import repo.doxygen
import repo.yum
import repo.zypper

parser = argparse.ArgumentParser(
        description="Add the newest packages from builds.globus.org to the unstable release")
parser.add_argument(
    "-r", "--root",
    help="Synchronize packages to the ROOT directory ["
            + repo.default_root + "]",
    default=repo.default_root)
parser.add_argument(
    "-a", "--api-root",
    help="Synchronize api docs to the API_ROOT directory ["
            + repo.default_api_root + "]",
    default=repo.default_api_root)
parser.add_argument(
    "-c", "--cache",
    help="Cache files in CACHE directory ["
            + repo.default_cache + "]",
    default=repo.default_cache)
parser.add_argument(
    "-p", "--package",
    help="Only sync the latest version of PACKAGE")
parser.add_argument(
    "-i", "--installers",
    help="Sync installers, not packages",
    dest="installers_only",
    action="store_true")
parser.add_argument(
    "-x", "--exclude-os-name",
    help="Do not process packages related to the OS_NAME. The OS_NAME string should be a comma-separated list of OSes to exclude. The form of the OS names are os/release for an RPM distro (e.g. el/5 or sles/11) or a codename for a Deb distro (e.g. wheezy)",
    dest="exclude_os_name",
    default=None)
parser.add_argument(
    "-t", "--repo-type",
    help="Only process repositories of type REPO_TYPE (deb,yum,packages,zypper)",
    dest="repo_type",
    default=None)

parser.add_argument(
    "-d", "--dryrun",
    help="Display packages that would be copied, but don't actually execute the copy",
    action='store_true')

parser.add_argument(
    "-v", "--verbose",
    help="Display packages that were copied",
    action='store_true')

args = parser.parse_args()
exclude_os_names = ["fedora/19", "fedora/20", "fedora/21", "fedora/22", "squeeze", "lucid", "utopic", "vivid", "wily" ]
if args.exclude_os_name is not None:
    exclude_os_names.extend(args.exclude_os_name.split(","))

if socket.gethostname() == 'globuscvs':
    gid = grp.getgrnam('globdev').gr_gid
    if os.getgid() != gid:
        print("Run newgrp globdev before running this script")
        exit(1)
    os.umask(0o2)
    repo.gid = gid

repo.setup_gpg_agent()

# Here we don't restrict the releases to ["unstable"], as we want at least
# an empty repository in "testing" and "stable" for each operating system
# we support so that the repo package doesn't complain about missing files
if not args.installers_only:
    print("==========================================")
    print("Caching changes from builds.globus.org....")
    print("==========================================")
    managers = dict()
    if args.repo_type == 'deb' or args.repo_type is None:
        print("Updating deb cache")
        managers['deb'] = repo.deb.Manager(cache_root=args.cache, root=args.root, exclude_os_names=exclude_os_names)

    if args.repo_type == 'yum' or args.repo_type is None:
        print("Updating yum cache")
        managers['yum'] = repo.yum.Manager(cache_root=args.cache, root=args.root, exclude_os_names=exclude_os_names)
    if args.repo_type == 'packages' or args.repo_type is None:
        print("Updating packages cache")
        managers['packages'] = repo.packages.Manager(cache_root=args.cache, root=args.root)
    if args.repo_type == 'zypper' or args.repo_type is None:
        print("Updating zypper cache")
        managers['zypper'] = repo.zypper.Manager(cache_root=args.cache, root=args.root, exclude_os_names=exclude_os_names)

    print("========================")
    print("Updating repositories...")
    print("========================")
    for man in managers:
        print("Updating %s repo" % man)
        manager = managers[man]
        packages = manager.promote_packages(name=args.package, dryrun=args.dryrun)

        if args.dryrun or args.verbose:
            print("\n".join([(p.path + " to " + p.os) for p in packages]))

if args.installers_only:
    print("==================================")
    print("Syncing with builds.globus.org....")
    print("==================================")
    managers = dict()
    print("Updating installers cache")
    managers['installers'] = repo.installers.Manager(
            cache_root=args.cache, root=args.root)
    print("Updating API docs cache")
    managers['doxygen'] = repo.doxygen.Manager(
            cache_root=args.cache, root=args.api_root)
    print("==============")
    print("Updating repos")
    print("==============")
    installers = []
    for man in managers:
        print("Updating %s repo" % man)
        manager = managers[man]
        installers = installers + manager.promote_packages(dryrun=args.dryrun)

    if args.dryrun or args.verbose:
        print("\n".join([(p.path + " to " + p.os) for p in installers]))
# vim: filetype=python:
